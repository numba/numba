-- Untyped IR with expression trees:
--
--    * Contains Basic Blocks and conditional and unconditional branches
--
-- The main difference with Normalized IR is that we have explicit basic
-- blocks and (annotated) control flow.
--
-- Each basic blocks ends with a branch to a new basic block, or a return.
-- High-level constructs such as exception handling blocks or loops are
-- annotated through Setup annotations (SetupLoop, SetupExcept,
-- SetupFinally, SetupWith)
--
--
-- Some differences:
--
--     Break        -> Branch
--     Continue     -> Branch
--     Raise        -> [ Raise ; Branch ]
--     If           -> CBranch
--     While        -> CBranch + SetupLoop
--     For          -> CBranch + SetupLoop + Iter + Next
--     TryFinally   -> Branch + SetupFinally
--     TryExcept    -> Branch + SetupExcept
--     With         -> Branch + SetupExcept + SetupFinally

module UnTyped version "0.1"
{

    -- Function. blocks[0] is the entry block
	func = FunctionDef(identifier name, arguments args,
                       block *entry, object *blocks, expr* decorator_list)

    -- Basic Block
    --    \ block.meta holds the metadata:
    --          { 'flags' : BLOCK_LOOP | BLOCK_EXCEPT | BLOCK_FINALLY }

    block = Block(op *body)
            attributes (object meta)

    stmt  = Print(expr? dest, expr* values, bool nl)
          | func

          ---------- Basic Block Terminators ----------

          -- Basic Control Flow
          | Branch(block bbdst)                     -- unconditional jump
          | CBranch(expr cond, block bbif, bbelse)  -- conditional jump
          | Return(expr? value)

          ---------- Basic Block Annotations ----------

          -- First instruction in the 'condition' block (after any phis)
          | SetupLoop(object bbbody, object bbexit)

          -- First instruction in the 'try' block (after any phis)
	      | SetupExcept(object bbexcept)
	      | SetupFinally(stmt* body, stmt* finalbody)

          ---------- Assignments and Scoping ----------

          | Phi(incoming *incoming)
          -- | Assign(expr target, expr value)
          -- | Delete(expr target)              -- Def(NULL)

	      | Global(identifier name)
          | Nonlocal(identifier name)

          ---------- Miscellaneous ----------

          | Raise(expr? type, expr? inst, expr? tback)
          | Assert(expr test, expr? msg)
	      | Exec(expr body, expr? globals, expr? locals)
	      | def

	      -- col_offset is the byte offset in the utf8 string the parser uses
	      attributes (int lineno, int col_offset, object meta)

	expr = BoolOp(expr left, boolop op, expr right)
	     | BinOp(expr left, operator op, expr right)
	     | UnaryOp(unaryop op, expr operand)

	     | Dict(expr* keys, expr* values)
         | Set(expr* elts)
         | List(expr* elts)
         | Tuple(expr* elts)

         -- Make imports expressions, the result of which are regular values!
         | Import(alias name)
         | ImportFrom(identifier? module, alias name, int? level)

	     | Yield(expr? value)
	     | Compare(expr left, cmpop op, expr right)
	     | Call(expr func, expr* args, keyword* keywords,
			    expr? starargs, expr? kwargs)
	     | Repr(expr value)
	     | Num(object n) -- a number as a PyObject.
	     | Str(string s) -- need to specify raw, unicode, etc?
	     -- other literals? bools?

	     -- the following expression can appear in assignment context
	     | Attribute(expr value, identifier attr, expr_context ctx)
	     | Subscript(expr value, slice *slice, expr_context ctx)
	     | Name(identifier id, expr_context ctx)
	     | Starred(expr value, expr_context ctx)

	     -- For loop Iteration
	     | Iter(expr iterable)
	     | Next(expr iterator)

	      -- col_offset is the byte offset in the utf8 string the parser uses
	      attributes (int lineno, int col_offset, object meta)

    ---------- SSA ----------

	def = Value(expr value)
	use = Use(object def)
	incoming = (object predecessor, object use)

    ---------- Miscellaneous ----------

	expr_context = Load | Store | Del | AugLoad | AugStore | Param

	slice = Ellipsis
	      | Slice(expr? lower, expr? upper, expr? step)
	      | Index(expr value)

	boolop = And | Or

	operator = Add | Sub | Mult | Div | Mod | Pow | LShift
                   | RShift | BitOr | BitXor | BitAnd | FloorDiv

	unaryop = Invert | Not | UAdd | USub

	cmpop = Eq | NotEq | Lt | LtE | Gt | GtE | Is | IsNot | In | NotIn

	comprehension = (expr target, expr iter, expr* ifs)

	-- not sure what to call the first argument for raise and except
	excepthandler = ExceptHandler(expr? type, expr? name, stmt* body)
	                attributes (int lineno, int col_offset)

	arguments = (expr* args, identifier? vararg,
		         identifier? kwarg, expr* defaults)

    -- keyword arguments supplied to call
    keyword = (identifier arg, expr value)

    -- import name with optional 'as' alias.
    alias = (identifier name, identifier? asname)
}